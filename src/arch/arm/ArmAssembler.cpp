/*
 * Copyright (c) 2026, Barcelona Supercomputing Center
 * Contact: mess             [at] bsc [dot] es
 *          victor.xirau     [at] bsc [dot] es
 *          petar.radojkovic [at] bsc [dot] es
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 *     * Neither the name of the copyright holder nor the names
 *       of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "arch/arm/ArmAssembler.h"
#include <iomanip>

std::string ArmAssembler::generateLoad(int /*offset*/, int reg) const {
    std::ostringstream oss;
    if (config_.isa_mode == ISAMode::SVE) {
        oss << "        \"ld1d {z" << reg << ".d}, p0/z, [x19];\\n\"\n"
            << "        \"add x19, x19, #64;\\n\"\n";
    } else {
        int r1 = (2 * reg) % 32;
        int r2 = (2 * reg + 1) % 32;
        oss << "        \"LDP Q" << r1 << ", Q" << r2 << ", [x19], #128;\\n\"\n";
    }
    return oss.str();
}

std::string ArmAssembler::generateStore(int /*offset*/, int reg) const {
    std::ostringstream oss;
    if (config_.isa_mode == ISAMode::SVE) {
        std::string op = config_.use_nontemporal_stores ? "stnt1d" : "st1d";
        oss << "        \"" << op << " {z" << reg << ".d}, p0, [x20];\\n\"\n"
            << "        \"add x20, x20, #64;\\n\"\n";
    } else {
        int r1 = (2 * reg) % 32;
        int r2 = (2 * reg + 1) % 32;
        oss << "        \"STP Q" << r1 << ", Q" << r2 << ", [x20], #128;\\n\"\n";
    }
    return oss.str();
}

std::string ArmAssembler::generateLoopControl(int increment, int labelId) const {
    std::ostringstream oss;

    auto safe_add = [](const char* reg, int val) {
        std::ostringstream ss;
        if (val < 4096 && val > -4096) {
             ss << "        \"add " << reg << ", " << reg << ", #" << val << ";\\n\"\n";
        } else {
             ss << "        \"movz x9, #0x" << std::hex << (val & 0xFFFF) << ";\\n\"\n";
             if (val > 0xFFFF) ss << "        \"movk x9, #0x" << std::hex << ((val >> 16) & 0xFFFF) << ", LSL #16;\\n\"\n";
             ss << "        \"add " << reg << ", " << reg << ", x9;\\n\"\n";
        }
        return ss.str();
    };

    int loopIncrement = increment;
    oss << "\n"
        << safe_add("x21", loopIncrement);

    oss << "        \"cmp x21, x22;\\n\"\n";
    oss << "        \"blt ..L_" << labelId << ";\\n\"\n";
    return oss.str();
}

std::string ArmAssembler::generatePause() const {
    return "        \"mov x11, x30;\\n\"\n"
           "        \"bl  nop_;\\n\"\n"
           "        \"mov x30, x11;\\n\"\n";
}

std::string ArmAssembler::generateHeader() const {
    std::ostringstream oss;
    oss << "/*\n"
        << " * Generated by Mess Kernel Generator (ARM)\n"
        << " * Mode: MultiSequential access\n"
        << " */\n\n"
        << "#include <stdio.h>\n"
        << "#include <unistd.h>\n"
        << "#include \"utils.h\"\n\n"
        << "void print_usage(char *argv[], char* usage)\n"
        << "{\n"
        << "    fprintf(stderr,\"Usage: %s %s\", argv[0], usage);\n"
        << "}\n\n";
    return oss.str();
}

std::string ArmAssembler::generateRegisterSetup() const {
    return "    register ssize_t i;\n"
           "    i = 0;\n\n";
}

std::string ArmAssembler::generateVectorRegisterInit() const {
    if (config_.isa_mode == ISAMode::SVE) {
        return "      \"ptrue p0.d;\\n\"\n";
    }
    return "";
}

std::string ArmAssembler::generateFooter() const {
    return "";
}

std::string ArmAssembler::generateAsmStart() const {
    return "    asm __volatile__ (\n"
           "      \"mov x21, #0x0;\\n\"\n"
           "      \"mov x19, %0;\\n\"\n"
           "      \"mov x20, %4;\\n\"\n"
           "      \"mov x22, %2;\\n\"\n"
           "      \"mov x4, %3;\\n\"";
}

std::string ArmAssembler::generateAsmEnd() const {
    if (config_.isa_mode == ISAMode::SVE) {
        return "      :\n"
               "      : \"r\" (a_array), \"r\" (i), \"r\" (*array_size), \"r\" (*pause), \"r\" (b_array)\n"
               "      : \"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\", \"x10\", \"x11\", \"x12\", \"x13\", \"x14\", \"x15\", \"x16\", \"x17\", \"x18\", \"x19\", \"x20\", \"x21\", \"x22\", \"x30\", \"z0\", \"p0\", \"memory\", \"cc\"\n"
               "    );\n";
    }
    return "      :\n"
           "      : \"r\" (a_array), \"r\" (i), \"r\" (*array_size), \"r\" (*pause), \"r\" (b_array)\n"
           "      : \"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x6\", \"x7\", \"x8\", \"x9\", \"x10\", \"x11\", \"x12\", \"x13\", \"x14\", \"x15\", \"x16\", \"x17\", \"x18\", \"x19\", \"x20\", \"x21\", \"x22\", \"x30\", \"q0\", \"q1\", \"memory\", \"cc\"\n"
           "    );\n";
}

std::string ArmAssembler::getPointerChaseLoopAsm() const {
    return "            \"subs %2, %2, #1;\"\n"
           "            \"b.ne start_loop_%%=;\"";
}

std::string ArmAssembler::getPointerChaseInstruction() const {
    return "        \"adds x3, %2, %1; ldr %1, [x3];\"";
}

std::string ArmAssembler::generatePointerChaseBurstLoop() const {
    return R"(
        register uint64_t i asm("x0") = BURST_ITERS;
        register struct line *start asm("x1") = array;
        register uint64_t next asm("x2") = current_offset;

        __asm__ __volatile__ (
            "start_loop_%=:"
            #include "loop.h"
            "subs %0, %0, #1;"
            "bne start_loop_%=;"
            : "+r" (i), "+r" (next)
            : "r" (start)
            : "x3", "cc", "memory"
        );

        current_offset = next;
)";
}

std::string ArmAssembler::generateNopFile() const {
    return R"(#include <stdlib.h>
#include <stdio.h>


void volatile nop_(void) {

    asm __volatile__ (
      "cmp x4, #0x0;\n"
      "bne start_pause;\n"
      "b end;\n"
      "start_pause:"
      "mov x10, x4;\n"
      "start_loop:\n"
      "nop;\n"
      "subs x10, x10, #0x01;\n"
      "cmp x10, #0x0;\n"
      "bne start_loop;\n"
      "end:"
      :
      :
      : "x30", "x4", "x10"
    );

}
)";
}

